<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="./dists/jquery.dataTables.min.css">		
<link rel="stylesheet" href="./dists/leaflet.css">
<style>
    body {
        margin: 0;
        padding: 0;
    }

    #map {
        width: 90%;
        height: 90vh;
    }
</style>

<script src="./dists/jquery.min.js"></script>
<script src="./dists/leaflet.js"></script>
   
</head>
<body>

<div id="map"></div>

</body>
<script>
	var map = L.map('map').setView([-40, 174], 6);
	
	var osm = L.tileLayer ('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
		attribution: '&copy; OSM'
	}).addTo(map);

	var aircraftMarkerOptions = {
		radius: 4,
		fillColor: "#787878",
		color: "#787878",
		weight: 1,
		opacity: 1,
		fillOpacity: 0.8
	};

	var tracksStyle = {
		"color": "#787878",
		"weight": 0.75,
		"opacity": 1
	};

	var nzStyle = {
		"color": "#000078",
		"weight": 2,
		"opacity": 1,
		fillOpacity: 0
	};

	var availabilityMarkerOptions = {
		fillColor: "#ff7800",
		color: "#ff7800",
		radius: 6,
		weight: 1,
		opacity: 1,
		fillOpacity: 1
	};
	
	// Set the global configs to synchronous while we get all the data
	$.ajaxSetup({
		async: false
	});

	// get tracks data
	var tracksData;
	$.getJSON('data/geoTracks.json', function(data) {
		//save the results
		tracksData = data;
	});
	
	// get locations data
	var currentLocationsData;
	$.getJSON('data/currentGeoLocations.json', function(data) {
		//save the results
		currentLocationsData = data;
	});
		
	// get aircraft data
	var aircraftData;
	$.getJSON('data/aircraft.json', function(data) {
		//save the results
		aircraftData = data;
	});
	
	// get availability data
	var availabilityData;
	$.getJSON('data/availability.json', function(data) {
		// strip out any data without coordiantes as these crash leaflet
		for( var i = 0; i < data.features.length; i++){		
			if ( data.features[i].geometry.coordinates.length < 2) { 
				data.features.splice(i, 1); 
				i--; 
			}
		};
		//save the results
		availabilityData = data;
	});
			
	// merge aircraft and availability data
	$.each(availabilityData.features, function(av, feature) {
		const availabilityId = feature.properties.asset_id;
		$.each(aircraftData.aircraft, function(i, aircraft) {
			const aircraftId = aircraft.id;
			if (availabilityId == aircraftId && !feature.properties.is_equipment) {
				feature.properties.registration = aircraft.registration;
				feature.properties.callsign = aircraft.callsign;
				feature.properties.operator = aircraft.operator;
				feature.properties.serviceRoles = aircraft.serviceRoles;
			}
		});
	});
   
	// create an Locations layer
	var currentLocationsLayer;
	currentLocationsLayer = L.geoJSON(currentLocationsData,{
		pointToLayer: function (feature, latlng) {
			return L.circleMarker(latlng, aircraftMarkerOptions);
		},
		onEachFeature: function(feature, layer) {
			if (feature.properties && feature.properties.assetRegistration && feature.properties.received) {
				var popuptext = "<Strong>GPS location </STRONG></BR>" + feature.properties.assetRegistration + "</BR>" + feature.properties.received;
				layer.bindPopup(popuptext);
			};
		}
	}).addTo(map);
		
	// create an availability layer
	var availabilityLayer;
	availabilityLayer = L.geoJSON(availabilityData,{
		pointToLayer: function (feature, latlng) {
			if (latlng && !feature.properties.is_equipment) {
				return L.circleMarker(latlng, availabilityMarkerOptions);
			}
		},
		onEachFeature: function(feature, layer) {
			if (feature.properties && feature.properties.event_name && feature.properties.response) {
				var popuptext = "Availability Location </BR>" +feature.properties.callsign + "</BR>" + feature.properties.registration + "</BR>" + feature.properties.event_name+ "</BR>" + feature.properties.response + " mins</BR>";
				if (feature.properties.operator && !feature.properties.operator.name  && feature.properties.operator.registeredName) {
					feature.properties.operator.name = feature.properties.operator.registeredName;
				}
				if (feature.properties.operator && feature.properties.operator.name  && feature.properties.operator.operationalContact) {
					popuptext = popuptext + feature.properties.operator.name + "</BR>" +feature.properties.operator.operationalContact;
				}
				layer.bindPopup(popuptext);
			}
		}
	}).addTo(map);
		
	// create an Tracks layer
	var tracksLayer;
	tracksLayer = L.geoJSON(tracksData,{
			style: tracksStyle
	}).addTo(map);

	var nzBoundaries
  	$.getJSON('spatial/nzcoast.json', function(data) {
        nzBoundaries = L.geoJSON(data,{
			style: nzStyle,
			onEachFeature: function(feature, layer) {
				layer.on({
					'add': function(){ layer.bringToBack() }
				})
			}
		}).addTo(map);
	});
	
	// Set the global configs back to asynchronous 
	$.ajaxSetup({
		async: true
	});

</script>
</html>